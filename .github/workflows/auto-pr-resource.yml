name: Auto-generate PR from Resource Submission

on:
  issues:
    types: [opened, edited, labeled]

jobs:
  create-pr:
    if: contains(github.event.issue.labels.*.name, 'resource-submission')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse issue and create PR
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body;
            
            // Parse the issue form fields
            function parseField(body, fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([\\s\\S]*?)(?=\\n### |$)`, 'i');
              const match = body.match(regex);
              if (match) {
                return match[1].trim();
              }
              return '';
            }
            
            function parseCheckboxes(body, fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n([\\s\\S]*?)(?=\\n### |$)`, 'i');
              const match = body.match(regex);
              if (!match) return [];
              
              const checkboxSection = match[1];
              const checked = [];
              const checkboxRegex = /- \[x\] (.+)/gi;
              let checkMatch;
              while ((checkMatch = checkboxRegex.exec(checkboxSection)) !== null) {
                checked.push(checkMatch[1].trim().replace(/^"|"$/g, ''));
              }
              return checked;
            }
            
            const title = parseField(body, 'Resource Title');
            const url = parseField(body, 'URL');
            const description = parseField(body, 'Description');
            const dialect = parseField(body, 'Dialect / Section');
            const tags = parseCheckboxes(body, 'Tags');
            
            if (!title || !url || !description || !dialect) {
              console.log('Missing required fields, skipping PR creation');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '‚ö†Ô∏è Could not parse all required fields from this submission. Please ensure Title, URL, Description, and Dialect are filled out.'
              });
              return;
            }
            
            // Map dialect to section function name and insertion marker
            const dialectMap = {
              'General Lisp Resources': { section: 'general-section', id: 'general' },
              'Common Lisp': { section: 'common-lisp-section', id: 'common-lisp' },
              'Scheme': { section: 'scheme-section', id: 'scheme' },
              'Racket': { section: 'racket-section', id: 'racket' },
              'Clojure': { section: 'clojure-section', id: 'clojure' },
              'Emacs Lisp': { section: 'emacs-lisp-section', id: 'emacs-lisp' },
              'Janet': { section: 'janet-section', id: 'janet' },
              'Other Lisps & Inspired Languages': { section: 'others-section', id: 'others' }
            };
            
            const sectionInfo = dialectMap[dialect];
            if (!sectionInfo) {
              console.log('Unknown dialect:', dialect);
              return;
            }
            
            // Format tags for Scheme
            const tagsScheme = tags.length > 0 
              ? `'(${tags.map(t => `"${t}"`).join(' ')})`
              : "'()";
            
            // Escape special characters for Scheme strings
            const escapeScheme = (str) => str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            
            // Create the resource-card s-expression
            const resourceCard = `                 ,(resource-card
                   "${escapeScheme(title)}"
                   "${escapeScheme(url)}"
                   "${escapeScheme(description)}"
                   ${tagsScheme})`;
            
            // Read the current index.scm file
            const fs = require('fs');
            const path = 'pages/index.scm';
            let content = fs.readFileSync(path, 'utf8');
            
            // Find the section and insert before the closing )))) of the resources-grid
            // We look for the section by its id and find the last resource-card in it
            const sectionRegex = new RegExp(
              `(\\(section \\(@ \\(id "${sectionInfo.id}"\\)[\\s\\S]*?\\(div \\(@ \\(class "resources-grid"\\)\\)[\\s\\S]*?)(\\)\\)\\)\\))`,
              'm'
            );
            
            const sectionMatch = content.match(sectionRegex);
            if (!sectionMatch) {
              console.log('Could not find section:', sectionInfo.id);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ö†Ô∏è Could not find the "${dialect}" section in index.scm. Manual intervention required.`
              });
              return;
            }
            
            // Insert the new resource card before the closing ))))
            const newContent = content.replace(
              sectionRegex,
              `$1\n${resourceCard}$2`
            );
            
            // Create a new branch
            const branchName = `resource/${issue.number}-${title.toLowerCase().replace(/[^a-z0-9]+/g, '-').slice(0, 30)}`;
            
            // Get the default branch SHA
            const { data: ref } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });
            
            // Create new branch
            try {
              await github.rest.git.createRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `refs/heads/${branchName}`,
                sha: ref.object.sha
              });
            } catch (e) {
              if (e.status === 422) {
                console.log('Branch already exists, updating...');
              } else {
                throw e;
              }
            }
            
            // Get the current file to get its SHA
            const { data: fileData } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: path,
              ref: branchName
            });
            
            // Update the file
            await github.rest.repos.createOrUpdateFileContents({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: path,
              message: `Add resource: ${title}`,
              content: Buffer.from(newContent).toString('base64'),
              sha: fileData.sha,
              branch: branchName
            });
            
            // Create the pull request
            const { data: pr } = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Add resource: ${title}`,
              head: branchName,
              base: 'main',
              body: `## New Resource Submission

            This PR was automatically generated from issue #${issue.number}.

            ### Resource Details
            - **Title:** ${title}
            - **URL:** ${url}
            - **Description:** ${description}
            - **Section:** ${dialect}
            - **Tags:** ${tags.join(', ') || 'none'}

            ---
            
            Please review the changes and merge if everything looks good.
            
            Closes #${issue.number}`
            });
            
            // Comment on the issue with the PR link
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `üéâ Thanks for your submission! A pull request has been automatically created: #${pr.number}\n\nA maintainer will review it shortly.`
            });
            
            console.log(`Created PR #${pr.number} for issue #${issue.number}`);

