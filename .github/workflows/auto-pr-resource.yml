name: Auto-generate PR from Resource Submission

on:
  issues:
    types: [opened, edited, labeled]

jobs:
  create-pr:
    if: contains(github.event.issue.labels.*.name, 'resource-submission')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Parse issue and create/update PR
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body;
            const action = context.payload.action;
            
            // Parse the issue form fields
            function parseField(body, fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*([\\s\\S]*?)(?=\\n### |$)`, 'i');
              const match = body.match(regex);
              if (match) {
                return match[1].trim();
              }
              return '';
            }
            
            function parseCheckboxes(body, fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n([\\s\\S]*?)(?=\\n### |$)`, 'i');
              const match = body.match(regex);
              if (!match) return [];
              
              const checkboxSection = match[1];
              const checked = [];
              const checkboxRegex = /- \[x\] (.+)/gi;
              let checkMatch;
              while ((checkMatch = checkboxRegex.exec(checkboxSection)) !== null) {
                checked.push(checkMatch[1].trim().replace(/^"|"$/g, ''));
              }
              return checked;
            }
            
            const title = parseField(body, 'Resource Title');
            const url = parseField(body, 'URL');
            const description = parseField(body, 'Description');
            const dialect = parseField(body, 'Dialect / Section');
            const tags = parseCheckboxes(body, 'Tags');
            
            if (!title || !url || !description || !dialect) {
              console.log('Missing required fields, skipping PR creation');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: '‚ö†Ô∏è Could not parse all required fields from this submission. Please ensure Title, URL, Description, and Dialect are filled out.'
              });
              return;
            }
            
            // Map dialect to section function name and insertion marker
            const dialectMap = {
              'General Lisp Resources': { section: 'general-section', id: 'general' },
              'Common Lisp': { section: 'common-lisp-section', id: 'common-lisp' },
              'Scheme': { section: 'scheme-section', id: 'scheme' },
              'Racket': { section: 'racket-section', id: 'racket' },
              'Clojure': { section: 'clojure-section', id: 'clojure' },
              'Emacs Lisp': { section: 'emacs-lisp-section', id: 'emacs-lisp' },
              'Janet': { section: 'janet-section', id: 'janet' },
              'Other Lisps & Inspired Languages': { section: 'others-section', id: 'others' }
            };
            
            const sectionInfo = dialectMap[dialect];
            if (!sectionInfo) {
              console.log('Unknown dialect:', dialect);
              return;
            }
            
            // Format tags for Scheme
            const tagsScheme = tags.length > 0 
              ? `'(${tags.map(t => `"${t}"`).join(' ')})`
              : "'()";
            
            // Escape special characters for Scheme strings
            const escapeScheme = (str) => str.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
            
            // Create the resource-card s-expression
            const resourceCard = `                 ,(resource-card
                   "${escapeScheme(title)}"
                   "${escapeScheme(url)}"
                   "${escapeScheme(description)}"
                   ${tagsScheme})`;
            
            // Consistent branch name based on issue number only
            const branchName = `resource/issue-${issue.number}`;
            
            // Check if a PR already exists for this issue
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branchName}`,
              state: 'open'
            });
            
            const existingPR = pulls.length > 0 ? pulls[0] : null;
            
            // Get the default branch SHA (latest main)
            const { data: mainRef } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: 'heads/main'
            });
            
            // Get the latest index.scm content from main
            const { data: mainFileData } = await github.rest.repos.getContent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              path: 'pages/index.scm',
              ref: 'main'
            });
            
            const content = Buffer.from(mainFileData.content, 'base64').toString('utf8');
            
            // Find the section and insert before the closing )))) of the resources-grid
            const sectionRegex = new RegExp(
              `(\\(section \\(@ \\(id "${sectionInfo.id}"\\)[\\s\\S]*?\\(div \\(@ \\(class "resources-grid"\\)\\)[\\s\\S]*?)(\\)\\)\\)\\))`,
              'm'
            );
            
            const sectionMatch = content.match(sectionRegex);
            if (!sectionMatch) {
              console.log('Could not find section:', sectionInfo.id);
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚ö†Ô∏è Could not find the "${dialect}" section in index.scm. Manual intervention required.`
              });
              return;
            }
            
            // Insert the new resource card before the closing ))))
            const newContent = content.replace(
              sectionRegex,
              `$1\n${resourceCard}$2`
            );
            
            const prBody = `## New Resource Submission

This PR was automatically generated from issue #${issue.number}.

### Resource Details
- **Title:** ${title}
- **URL:** ${url}
- **Description:** ${description}
- **Section:** ${dialect}
- **Tags:** ${tags.join(', ') || 'none'}

---

Please review the changes and merge if everything looks good.

Closes #${issue.number}`;
            
            if (existingPR) {
              // UPDATE existing PR: reset branch to main and apply new changes
              console.log(`Updating existing PR #${existingPR.number}`);
              
              // Force update the branch ref to point to main
              await github.rest.git.updateRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${branchName}`,
                sha: mainRef.object.sha,
                force: true
              });
              
              // Get the file SHA from the reset branch (now same as main)
              const { data: branchFileData } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'pages/index.scm',
                ref: branchName
              });
              
              // Update the file with new content
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'pages/index.scm',
                message: `Update resource: ${title}`,
                content: Buffer.from(newContent).toString('base64'),
                sha: branchFileData.sha,
                branch: branchName
              });
              
              // Update PR title and body
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: existingPR.number,
                title: `Add resource: ${title}`,
                body: prBody
              });
              
              // Comment on the issue about the update
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üîÑ Pull request #${existingPR.number} has been updated with your changes.`
              });
              
              console.log(`Updated PR #${existingPR.number} for issue #${issue.number}`);
              
            } else {
              // CREATE new PR
              console.log('Creating new PR');
              
              // Create new branch from main
              try {
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: mainRef.object.sha
                });
              } catch (e) {
                if (e.status === 422) {
                  // Branch exists but no PR - reset it
                  await github.rest.git.updateRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `heads/${branchName}`,
                    sha: mainRef.object.sha,
                    force: true
                  });
                } else {
                  throw e;
                }
              }
              
              // Get the file SHA from the new branch
              const { data: branchFileData } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'pages/index.scm',
                ref: branchName
              });
              
              // Update the file
              await github.rest.repos.createOrUpdateFileContents({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'pages/index.scm',
                message: `Add resource: ${title}`,
                content: Buffer.from(newContent).toString('base64'),
                sha: branchFileData.sha,
                branch: branchName
              });
              
              // Create the pull request
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `Add resource: ${title}`,
                head: branchName,
                base: 'main',
                body: prBody
              });
              
              // Comment on the issue with the PR link
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `üéâ Thanks for your submission! A pull request has been automatically created: #${pr.number}\n\nA maintainer will review it shortly.`
              });
              
              console.log(`Created PR #${pr.number} for issue #${issue.number}`);
            }
